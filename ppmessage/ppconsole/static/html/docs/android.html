        <div class="container">
            
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a data-target="#android-sdk" ng-style="{'cursor':'pointer'}"  ng-click="scrollTo($event, 'android-sdk')">Android SDK</a></li>
        
            <li><a data-target="#ppmessage" ng-style="{'cursor':'pointer'}"  ng-click="scrollTo($event, 'ppmessage')">PPMESSAGE简介</a></li>
        
            <li><a data-target="#_1" ng-style="{'cursor':'pointer'}"  ng-click="scrollTo($event, '_1')">名词解释</a></li>
        
            <li><a data-target="#_7" ng-style="{'cursor':'pointer'}"  ng-click="scrollTo($event, '_7')">集成与使用</a></li>
        
    
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="android-sdk" style="padding-top:1px;">Android SDK</h1>
<p>PPMESSAGE提供了丰富的SDK供开发者选择和使用，Android SDK主要针对PPMESSAGE的注册用户的Android应用系统集成PPMESSAGE系统用户端界面的接口。</p>
<h2 id="ppmessage">PPMESSAGE简介</h2>
<p>PPMESSAGE是一个即插即用的云客户服务系统。依托其在线云系统，为网站和移动应用提供统一的在线客服系统。PPMESSAGE提供户端嵌入代码、客服座席端应用以及PPMESSAGE平台服务接口。用户端嵌入代码支持 Web，Android，iOS，可以快速集成到网站和手机应用之中；平台服务接口是PPMESSAGE开放的服务的访问最底层协议，使用这些接口可以用来与PPMESSAGE进行深度集成，例如同步用户数据，创建和管理客服分组、获取历史消息等；客服座席端应用由PPMESSAGE单独提供，支持各种PC平台（Windows，Mac OS X，Linux），主流浏览器（IE、Safari、Chrome、Firefox），主流移动操作系统（Android、iOS、Windows Phone）；座席人员通过使用座席客户端进行在线服务。另外通过PPMESSAGE的后台服务管理配置可以管理服务团队的欢迎信息，离线信息，用户端界面风格，消息分流策略等。</p>
<h2 id="_1">名词解释</h2>
<p>在PPMESSAGE系统及其文档描述中出现以下名词，其所指的含义，这些含义可能与常识不同。为了避免混淆，在这里进行列举并解释。</p>
<h3 id="_2">注册用户</h3>
<p>在PPMESSAGE官网完成注册流程，即成为PPMESSAGE的注册用户。</p>
<h3 id="_3">客服团队</h3>
<p>客服团队是由注册用户在注册过程中创建的，其目的是为网站或APP提供在线客服功能。客服团队由管理员和客服共同组成。</p>
<h3 id="_4">管理员</h3>
<p>管理员是客服团队的管理者。在这里，我们默认PPMESSAGE的注册用户就是客服团队的管理员。</p>
<h3 id="_5">客服</h3>
<p>客服是由管理员在客服团队中创建的，是客服团队客服工作的主要承担者，其职责是根据管理员的要求做好网站或app的客服工作。</p>
<h3 id="_6">用户</h3>
<p>即网站或APP的用户，也是客服团队的服务对象（如，某电子商务商城的买家）。用户可以在网站或APP向客服团队咨询问题，然后由客服团队来解答其提出的问题。</p>
<h2 id="_7">集成与使用</h2>
<h3 id="_8">需求</h3>
<p>下载 PPMESSAGE Android SDK 和 Android SDK Demo。
确认使用 Eclipse 来开发 Android 应用。
Google Android SDK API 9，Android 2.3 以上。</p>
<h3 id="_9">第一步</h3>
<p>将下载好的 PPCom_Android_SDK 开发包进行解压，之后将其导入("File"-"Import"-"Android"-"Existing Android Code Into Workspace")到 eclipse 中，然后使你的项目引用它。</p>
<h3 id="_10">第二步</h3>
<p>编辑AndroidManifest.xml文件，添加权限。
打开你的项目的 AndroidManifest.xml 文件，对照着SDK目录下面的 AndroidManifest.xml ，将下面的这段代码添加进你的 AndroidManifest.xml 文件中去。</p>
<h4 id="_11">添加权限</h4>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;
</code></pre>

<h3 id="_12">第三步</h3>
<p>开发包包含两个基本View组件：</p>
<ol>
<li>PPLaunchView</li>
<li>PPComView</li>
</ol>
<h4 id="pplauncherview">PPLauncherView</h4>
<p><code>PPLauncherView</code>是一个小的美观的按钮，可以让用户通过点击这个小按钮进入到反馈界面中去。你可以通过xml配置或者代码使用它，也可以编写你自己的View来替换它。</p>
<h5 id="xmlpplauncherview">通过xml配置使用<code>PPLauncherView</code></h5>
<pre><code class="xml">&lt;com.yvertical.ppcomlib.view.PPLauncherView
    android:id=&quot;@+id/launcherView&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
&lt;/com.yvertical.ppcomlib.view.PPLauncherView&gt;
</code></pre>

<h5 id="pplauncherview_1">通过代码使用<code>PPLauncherView</code></h5>
<pre><code class="java">PPLauncherView mLauncherView = new PPLauncherView(getContext());
</code></pre>

<h5 id="_13">设置监听事件</h5>
<pre><code class="java">PPLauncherView mLauncherView = new PPLauncherView(getContext());
//PPLauncherView mLauncherView = findViewById(R.id.launcherView);

mLauncherView.setOnClickListener(new View.OnClickListener(){
    @Override
    public void onClick(View v) {
        //open feedback activity
    }
});
</code></pre>

<h4 id="ppcomview"><code>PPComView</code></h4>
<p><code>PPComView</code>是核心聊天界面的View，用户可以在这个View中创建会话、对客服进行反馈会话等。可以通过xml配置或者代码来使用它。</p>
<h5 id="xmlppcomview">通过xml配置使用<code>PPComView</code></h5>
<pre><code class="xml">&lt;com.yvertical.ppcomlib.view.PPComView
    android:id=&quot;@+id/ppcomView&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
&lt;/com.yvertical.ppcomlib.view.PPComView&gt;
</code></pre>

<h5 id="ppcomview_1">通过代码使用<code>PPComView</code></h5>
<pre><code class="java">PPComView mComView = new PPComView(getContext());
</code></pre>

<h5 id="ppcomview_2">初始化<code>PPComView</code></h5>
<pre><code class="java">PPComView mComView = new PPComView(getContext());
//PPComView mComView = findViewById(R.id.ppcomView);

// 通过 PPComView.PPComConfig 来配置 PPComView 一些基本信息
ppComView.init(
    getFragmentManager(),
    new PPComView.PPComConfig(
        &quot;你的AppKey&quot;,
        &quot;你的AppSecret&quot;)
        .setEnterKeyToSendMessage(true) //软键盘的 Enter 键是否可以发送消息
        .setUserEmail(&quot;somebody.web@yvertical.com&quot;) //用户邮箱，不填为匿名用户
    );
</code></pre>

<h5 id="activity">遵循<code>Activity</code>生命周期</h5>
<p>如果<code>PPComView</code>是放在<code>Activity</code>中的，那么需要遵循<code>Activity</code>的生命周期，否则会出现异常。如下所示：</p>
<p><code>FeedBackActivity.java</code>源码：</p>
<pre><code class="java">public class FeedBackActivity extends AppCompatActivity {

    private PPComView ppComView;

    @SuppressLint(&quot;NewApi&quot;)
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ppComView = new PPComView(this);
        setContentView(ppComView);

        ppComView.init(
                getFragmentManager(),
                new PPComView.PPComConfig(Constants.PPCOM_APP_KEY,
                        Constants.PPCOM_APP_SECRET).setEnterKeyToSendMessage(
                        true).setUserEmail(&quot;somebody.web@yvertical.com&quot;));
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (ppComView != null
                &amp;&amp; !ppComView.onActivityResult(requestCode, resultCode, data)) {
            super.onActivityResult(requestCode, resultCode, data);
        }
    }

    @Override
    public void onBackPressed() {
        if (ppComView != null &amp;&amp; !ppComView.onBackPressed()) {
            super.onBackPressed();
        }
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        if (ppComView != null) {
            ppComView.onSaveInstanceState(outState);
        }
    }

    @Override
    protected void onRestoreInstanceState(Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState);
        if (ppComView != null) {
            ppComView.onRestoreInstanceState(savedInstanceState);
        }
    }

    @Override
    protected void onPause() {
        super.onPause();
        if (ppComView != null) {
            ppComView.onPause();
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (ppComView != null) {
            ppComView.onResume();
        }
    }

    @Override
    protected void onStop() {
        super.onStop();
        if (ppComView != null) {
            ppComView.onStop();
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (ppComView != null) {
            ppComView.onDestroy();
        }
    }

}
</code></pre>

<h5 id="fragtment">遵循<code>Fragtment</code>生命周期</h5>
<p>如果<code>PPComView</code>是放在<code>Fragment</code>中的，那么需要遵循<code>Fragment</code>的生命周期，否则会出现异常。如下所示：</p>
<p><code>FeedBackFragment.java</code>源码：</p>
<pre><code class="java">public class FeedBackFragment extends Fragment {

    private static final String TAG = FeedBackFragment.class.getSimpleName();

    private PPComView ppComView;

    public FeedBackFragment() {

    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        android.util.Log.d(TAG, &quot;onCreateView&quot;);
        ppComView = (PPComView) inflater.inflate(R.layout.ppcom, container,
                false);
        ppComView.init(
                getFragmentManager(),
                new PPComView.PPComConfig(Constants.PPCOM_APP_KEY,
                        Constants.PPCOM_APP_SECRET).setEnterKeyToSendMessage(
                        true).setUserEmail(&quot;somebody.web@yvertical.com&quot;));
        return ppComView;
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        if (savedInstanceState != null) {
            if (ppComView != null) {
                ppComView.onRestoreInstanceState(savedInstanceState);
            }
        }
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        if (ppComView != null) {
            ppComView.onSaveInstanceState(outState);
        }
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        if (ppComView != null) {
            ppComView.onDestroy();
        }
    }

    @Override
    public void onPause() {
        super.onPause();
        if (ppComView != null) {
            ppComView.onPause();
        }
    }

    @Override
    public void onResume() {
        super.onResume();
        if (ppComView != null) {
            ppComView.onResume();
        }
    }

    @Override
    public void onStop() {
        super.onStop();
        if (ppComView != null) {
            ppComView.onStop();
        }
    }

    public boolean handledActivityResult(int requestCode, int resultCode,
            Intent data) {
        if (ppComView != null) {
            return ppComView.onActivityResult(requestCode, resultCode, data);
        }
        return false;
    }

    public boolean onBackPressed() {
        if (ppComView != null) {
            return ppComView.onBackPressed();
        }
        return false;
    }
}
</code></pre>

<p>当在<code>Fragment</code>中使用的时候，<code>Fragment</code>所在的<code>Activity</code>应该处理<code>onBackPressed</code>和<code>onActivityResult</code>事件，如下所示：</p>
<pre><code class="java">public class FeedBackFragmentActivity extends AppCompatActivity {

    private FeedBackFragment mFeedBackFragment;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_feedback_fragment);

        mFeedBackFragment = (FeedBackFragment) getSupportFragmentManager()
                .findFragmentById(R.id.mFeedbackFrag);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (!mFeedBackFragment.handledActivityResult(requestCode, resultCode,
                data)) {
            super.onActivityResult(requestCode, resultCode, data);
        }
    }

    @Override
    public void onBackPressed() {
        if (!mFeedBackFragment.onBackPressed()) {
            super.onBackPressed();
        }
    }
}
</code></pre></div>
            
        </div>

